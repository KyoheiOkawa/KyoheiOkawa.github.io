<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BaseCrossRef: basecross::Vector4EX 名前空間</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BaseCrossRef
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebasecross.html">basecross</a></li><li class="navelem"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html">Vector4EX</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">関数</a>  </div>
  <div class="headertitle">
<div class="title">basecross::Vector4EX 名前空間</div>  </div>
</div><!--header-->
<div class="contents">

<p>Vector4EX（4次元ベクトル）ネームスペース  
<a href="#details">[詳解]</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
関数</h2></td></tr>
<tr class="memitem:a0a66d829f89eaf01f07e20eb516363d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#a0a66d829f89eaf01f07e20eb516363d4">WStr4ToVec4</a> (wstring &amp;x_str, wstring &amp;y_str, wstring &amp;z_str, wstring &amp;w_str)</td></tr>
<tr class="memdesc:a0a66d829f89eaf01f07e20eb516363d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字列から作成する  <a href="#a0a66d829f89eaf01f07e20eb516363d4">[詳解]</a><br /></td></tr>
<tr class="separator:a0a66d829f89eaf01f07e20eb516363d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0faec4620e747c1a6a4356fc4e7255"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#a6b0faec4620e747c1a6a4356fc4e7255">Equal</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;other)</td></tr>
<tr class="memdesc:a6b0faec4620e747c1a6a4356fc4e7255"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルがもう一つのベクトルと等しいかどうかを検証する  <a href="#a6b0faec4620e747c1a6a4356fc4e7255">[詳解]</a><br /></td></tr>
<tr class="separator:a6b0faec4620e747c1a6a4356fc4e7255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757ca7049c97e2d47ade7c48fcd94dfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#a757ca7049c97e2d47ade7c48fcd94dfe">EqualInt</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;other)</td></tr>
<tr class="memdesc:a757ca7049c97e2d47ade7c48fcd94dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルがもう一つのベクトルと等しいかどうかを検証する。<br />
 それぞれの要素は符号なし整数として扱う  <a href="#a757ca7049c97e2d47ade7c48fcd94dfe">[詳解]</a><br /></td></tr>
<tr class="separator:a757ca7049c97e2d47ade7c48fcd94dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10ccda90bd0c54237cdae1c1b92e7c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#ae10ccda90bd0c54237cdae1c1b92e7c1">Greater</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;other)</td></tr>
<tr class="memdesc:ae10ccda90bd0c54237cdae1c1b92e7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルがもう一つのベクトルより大きいかどうかを検証する  <a href="#ae10ccda90bd0c54237cdae1c1b92e7c1">[詳解]</a><br /></td></tr>
<tr class="separator:ae10ccda90bd0c54237cdae1c1b92e7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16113c4aa25e0543c3aa2270f3f3539"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#ad16113c4aa25e0543c3aa2270f3f3539">GreaterOrEqual</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;other)</td></tr>
<tr class="memdesc:ad16113c4aa25e0543c3aa2270f3f3539"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルがもう一つのベクトル以上の大きさかどうかを検証する  <a href="#ad16113c4aa25e0543c3aa2270f3f3539">[詳解]</a><br /></td></tr>
<tr class="separator:ad16113c4aa25e0543c3aa2270f3f3539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab904266a8978c0d23398268dee66b807"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#ab904266a8978c0d23398268dee66b807">IsInfinite</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec)</td></tr>
<tr class="memdesc:ab904266a8978c0d23398268dee66b807"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルが値のいずれかが正か負の無限大かどうかを検証する  <a href="#ab904266a8978c0d23398268dee66b807">[詳解]</a><br /></td></tr>
<tr class="separator:ab904266a8978c0d23398268dee66b807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae642ddf936f45812f8ac36093141c1e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#ae642ddf936f45812f8ac36093141c1e6">IsNaN</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec)</td></tr>
<tr class="memdesc:ae642ddf936f45812f8ac36093141c1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの値のいずれかが非数（無効値）かどうかを検証する  <a href="#ae642ddf936f45812f8ac36093141c1e6">[詳解]</a><br /></td></tr>
<tr class="separator:ae642ddf936f45812f8ac36093141c1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbffd9a152c1caafca78670f08c8ab7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#afbffd9a152c1caafca78670f08c8ab7e">Less</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;other)</td></tr>
<tr class="memdesc:afbffd9a152c1caafca78670f08c8ab7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルがもう一つのベクトルより小さいかどうかを検証する  <a href="#afbffd9a152c1caafca78670f08c8ab7e">[詳解]</a><br /></td></tr>
<tr class="separator:afbffd9a152c1caafca78670f08c8ab7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa1e4298f1175b9bb169167bd16e2db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#a6aa1e4298f1175b9bb169167bd16e2db">LessOrEqual</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;other)</td></tr>
<tr class="memdesc:a6aa1e4298f1175b9bb169167bd16e2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルがもう一つのベクトル以下の大きさかどうかを検証する  <a href="#a6aa1e4298f1175b9bb169167bd16e2db">[詳解]</a><br /></td></tr>
<tr class="separator:a6aa1e4298f1175b9bb169167bd16e2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72959a69e80b1bbcd3311ba43e79c78c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#a72959a69e80b1bbcd3311ba43e79c78c">NearEqual</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;other, float Epsilon)</td></tr>
<tr class="memdesc:a72959a69e80b1bbcd3311ba43e79c78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルがもう一つのベクトルが近い大きさかどうかを検証する。  <a href="#a72959a69e80b1bbcd3311ba43e79c78c">[詳解]</a><br /></td></tr>
<tr class="separator:a72959a69e80b1bbcd3311ba43e79c78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2c4eae4461e9a4e761b111294de417"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#a4a2c4eae4461e9a4e761b111294de417">NotEqual</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;other)</td></tr>
<tr class="memdesc:a4a2c4eae4461e9a4e761b111294de417"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルがもう一つのベクトルと等しくないかどうかを検証する  <a href="#a4a2c4eae4461e9a4e761b111294de417">[詳解]</a><br /></td></tr>
<tr class="separator:a4a2c4eae4461e9a4e761b111294de417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91057de115e41b355fde87570cf5f2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#aa91057de115e41b355fde87570cf5f2c">NotEqualInt</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;other)</td></tr>
<tr class="memdesc:aa91057de115e41b355fde87570cf5f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルがもう一つのベクトルと等しくないかどうかを検証する<br />
 それぞれの要素は符号なし整数として扱う  <a href="#aa91057de115e41b355fde87570cf5f2c">[詳解]</a><br /></td></tr>
<tr class="separator:aa91057de115e41b355fde87570cf5f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81f2c28d3af283282c4a4556378aa7e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#af81f2c28d3af283282c4a4556378aa7e">AngleBetweenNormals</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec1, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec2)</td></tr>
<tr class="memdesc:af81f2c28d3af283282c4a4556378aa7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">正規化したベクトル同士のラジアン角度を計算する。正規化はしないので、引数ははあらかじめ正規化しておく<br />
 ベクトルのラジアン角計算では、正規化しない分速い  <a href="#af81f2c28d3af283282c4a4556378aa7e">[詳解]</a><br /></td></tr>
<tr class="separator:af81f2c28d3af283282c4a4556378aa7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f2757450b6776f7fc69d4f512d6bd5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#ab3f2757450b6776f7fc69d4f512d6bd5">AngleBetweenNormalsEst</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec1, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec2)</td></tr>
<tr class="memdesc:ab3f2757450b6776f7fc69d4f512d6bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">正規化したベクトル同士のラジアン角度を計算予測する。正規化はしないので、引数ははあらかじめ正規化しておく<br />
 ベクトルのラジアン角計算では、正規化しない分速い  <a href="#ab3f2757450b6776f7fc69d4f512d6bd5">[詳解]</a><br /></td></tr>
<tr class="separator:ab3f2757450b6776f7fc69d4f512d6bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4755bb68ede47841d18c2caeb96ca88f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#a4755bb68ede47841d18c2caeb96ca88f">AngleBetweenVectors</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec1, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec2)</td></tr>
<tr class="memdesc:a4755bb68ede47841d18c2caeb96ca88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">2つのベクトル間のラジアン角を計算する  <a href="#a4755bb68ede47841d18c2caeb96ca88f">[詳解]</a><br /></td></tr>
<tr class="separator:a4755bb68ede47841d18c2caeb96ca88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fb7eef54c8ee0a52659dd454a3ef0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#ae9fb7eef54c8ee0a52659dd454a3ef0c">ClampLength</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, float LengthMin, float LengthMax)</td></tr>
<tr class="memdesc:ae9fb7eef54c8ee0a52659dd454a3ef0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの長さを指定した大きさにクランプする  <a href="#ae9fb7eef54c8ee0a52659dd454a3ef0c">[詳解]</a><br /></td></tr>
<tr class="separator:ae9fb7eef54c8ee0a52659dd454a3ef0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab672883516c61d01f97e2581dd726b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#a2ab672883516c61d01f97e2581dd726b">ClampLengthV</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;LengthMinV, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;LengthMaxV)</td></tr>
<tr class="memdesc:a2ab672883516c61d01f97e2581dd726b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの長さを指定した大きさにクランプする  <a href="#a2ab672883516c61d01f97e2581dd726b">[詳解]</a><br /></td></tr>
<tr class="separator:a2ab672883516c61d01f97e2581dd726b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef1ab73c59312ab38800abcb6f61bfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#a3ef1ab73c59312ab38800abcb6f61bfd">Cross</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec1, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec2, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec3)</td></tr>
<tr class="memdesc:a3ef1ab73c59312ab38800abcb6f61bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">外積を計算して返す  <a href="#a3ef1ab73c59312ab38800abcb6f61bfd">[詳解]</a><br /></td></tr>
<tr class="separator:a3ef1ab73c59312ab38800abcb6f61bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af971831697890648e35362b42b1b86fc"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#af971831697890648e35362b42b1b86fc">Dot</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec1, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec2)</td></tr>
<tr class="memdesc:af971831697890648e35362b42b1b86fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">内積を計算して返す  <a href="#af971831697890648e35362b42b1b86fc">[詳解]</a><br /></td></tr>
<tr class="separator:af971831697890648e35362b42b1b86fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12259ca92c539a118b99d86b7d092c9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#a12259ca92c539a118b99d86b7d092c9d">InBounds</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec1, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec2)</td></tr>
<tr class="memdesc:a12259ca92c539a118b99d86b7d092c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">すべての要素が、設定された境界ベクトル内にある場合はtrueを返す  <a href="#a12259ca92c539a118b99d86b7d092c9d">[詳解]</a><br /></td></tr>
<tr class="separator:a12259ca92c539a118b99d86b7d092c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb89c3ca92fe53a375eb39d581e43a85"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#acb89c3ca92fe53a375eb39d581e43a85">Length</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec)</td></tr>
<tr class="memdesc:acb89c3ca92fe53a375eb39d581e43a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの長さを返す  <a href="#acb89c3ca92fe53a375eb39d581e43a85">[詳解]</a><br /></td></tr>
<tr class="separator:acb89c3ca92fe53a375eb39d581e43a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ea289b234a23b72eacee963246ac17"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#af9ea289b234a23b72eacee963246ac17">LengthEst</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec)</td></tr>
<tr class="memdesc:af9ea289b234a23b72eacee963246ac17"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの長さを予想して返す  <a href="#af9ea289b234a23b72eacee963246ac17">[詳解]</a><br /></td></tr>
<tr class="separator:af9ea289b234a23b72eacee963246ac17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20acf896961b8c800a03c1e75987cacc"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#a20acf896961b8c800a03c1e75987cacc">LengthSq</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec)</td></tr>
<tr class="memdesc:a20acf896961b8c800a03c1e75987cacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの長さの2乗を返す  <a href="#a20acf896961b8c800a03c1e75987cacc">[詳解]</a><br /></td></tr>
<tr class="separator:a20acf896961b8c800a03c1e75987cacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4053e6d675ae1335589c615a948d17d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#a4053e6d675ae1335589c615a948d17d3">Normalize</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec)</td></tr>
<tr class="memdesc:a4053e6d675ae1335589c615a948d17d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルを正規化する  <a href="#a4053e6d675ae1335589c615a948d17d3">[詳解]</a><br /></td></tr>
<tr class="separator:a4053e6d675ae1335589c615a948d17d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8da7c365f396c4ad9d91b3050c47626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#af8da7c365f396c4ad9d91b3050c47626">NormalizeEst</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec)</td></tr>
<tr class="memdesc:af8da7c365f396c4ad9d91b3050c47626"><td class="mdescLeft">&#160;</td><td class="mdescRight">正規化の予想ベクトルを返す  <a href="#af8da7c365f396c4ad9d91b3050c47626">[詳解]</a><br /></td></tr>
<tr class="separator:af8da7c365f396c4ad9d91b3050c47626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad232f0c462f525a39c36fe29b0b13f58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#ad232f0c462f525a39c36fe29b0b13f58">Orthogonal</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec)</td></tr>
<tr class="memdesc:ad232f0c462f525a39c36fe29b0b13f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">垂直なベクトルを返す  <a href="#ad232f0c462f525a39c36fe29b0b13f58">[詳解]</a><br /></td></tr>
<tr class="separator:ad232f0c462f525a39c36fe29b0b13f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe9c2c782ce652d9f121f4c84b3a281"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#aefe9c2c782ce652d9f121f4c84b3a281">ReciprocalLength</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec)</td></tr>
<tr class="memdesc:aefe9c2c782ce652d9f121f4c84b3a281"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの長さの逆数を返す  <a href="#aefe9c2c782ce652d9f121f4c84b3a281">[詳解]</a><br /></td></tr>
<tr class="separator:aefe9c2c782ce652d9f121f4c84b3a281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4f0def784a2561185ec00cb3dc375e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#aab4f0def784a2561185ec00cb3dc375e">ReciprocalLengthEst</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec)</td></tr>
<tr class="memdesc:aab4f0def784a2561185ec00cb3dc375e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの長さの逆数の予測値を返す  <a href="#aab4f0def784a2561185ec00cb3dc375e">[詳解]</a><br /></td></tr>
<tr class="separator:aab4f0def784a2561185ec00cb3dc375e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad746317e16d70554496f2e0e7e27244"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#aad746317e16d70554496f2e0e7e27244">Reflect</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Normal)</td></tr>
<tr class="memdesc:aad746317e16d70554496f2e0e7e27244"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルを法線ベクトルによって反射させたベクトル(入射ベクトル)を返す  <a href="#aad746317e16d70554496f2e0e7e27244">[詳解]</a><br /></td></tr>
<tr class="separator:aad746317e16d70554496f2e0e7e27244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29bbccba62830f569f54b9476c5c4d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#ad29bbccba62830f569f54b9476c5c4d7">Refract</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Normal, float RefractionIndex)</td></tr>
<tr class="memdesc:ad29bbccba62830f569f54b9476c5c4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルを法線ベクトルによって屈折率で反射させたベクトル(入射ベクトル)を返す  <a href="#ad29bbccba62830f569f54b9476c5c4d7">[詳解]</a><br /></td></tr>
<tr class="separator:ad29bbccba62830f569f54b9476c5c4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669b849a4b9e51f47aa544ab011edc74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#a669b849a4b9e51f47aa544ab011edc74">RefractV</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Normal, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;RefractionIndex)</td></tr>
<tr class="memdesc:a669b849a4b9e51f47aa544ab011edc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルを法線ベクトルによって屈折率ベクトル（すべての要素が同じ値）で反射させたベクトル(入射ベクトル)を返す  <a href="#a669b849a4b9e51f47aa544ab011edc74">[詳解]</a><br /></td></tr>
<tr class="separator:a669b849a4b9e51f47aa544ab011edc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c818b95198662687b233fe82194933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#af8c818b95198662687b233fe82194933">Transform</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const XMMATRIX &amp;m)</td></tr>
<tr class="memdesc:af8c818b95198662687b233fe82194933"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルをmによってトランスフォームさせたベクトルを返す  <a href="#af8c818b95198662687b233fe82194933">[詳解]</a><br /></td></tr>
<tr class="separator:af8c818b95198662687b233fe82194933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7216ec7f137e6f17fcaf2521d9fe97b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebasecross_1_1_vector4_e_x.html#af7216ec7f137e6f17fcaf2521d9fe97b">Transform</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Vec, const <a class="el" href="structbasecross_1_1_matrix4_x4.html">Matrix4X4</a> &amp;m)</td></tr>
<tr class="memdesc:af7216ec7f137e6f17fcaf2521d9fe97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルをmによってトランスフォームさせたベクトルを返す  <a href="#af7216ec7f137e6f17fcaf2521d9fe97b">[詳解]</a><br /></td></tr>
<tr class="separator:af7216ec7f137e6f17fcaf2521d9fe97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>Vector4EX（4次元ベクトル）ネームスペース </p>
</div><h2 class="groupheader">関数詳解</h2>
<a id="af81f2c28d3af283282c4a4556378aa7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81f2c28d3af283282c4a4556378aa7e">&#9670;&nbsp;</a></span>AngleBetweenNormals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float basecross::Vector4EX::AngleBetweenNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>正規化したベクトル同士のラジアン角度を計算する。正規化はしないので、引数ははあらかじめ正規化しておく<br />
 ベクトルのラジアン角計算では、正規化しない分速い </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec1</td><td>ベクトル1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec2</td><td>ベクトル2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ラジアン角 </dd></dl>

</div>
</div>
<a id="ab3f2757450b6776f7fc69d4f512d6bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f2757450b6776f7fc69d4f512d6bd5">&#9670;&nbsp;</a></span>AngleBetweenNormalsEst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float basecross::Vector4EX::AngleBetweenNormalsEst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>正規化したベクトル同士のラジアン角度を計算予測する。正規化はしないので、引数ははあらかじめ正規化しておく<br />
 ベクトルのラジアン角計算では、正規化しない分速い </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec1</td><td>ベクトル1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec2</td><td>ベクトル2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ラジアン角 </dd></dl>

</div>
</div>
<a id="a4755bb68ede47841d18c2caeb96ca88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4755bb68ede47841d18c2caeb96ca88f">&#9670;&nbsp;</a></span>AngleBetweenVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float basecross::Vector4EX::AngleBetweenVectors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2つのベクトル間のラジアン角を計算する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec1</td><td>ベクトル1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec2</td><td>ベクトル2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ラジアン角 </dd></dl>

</div>
</div>
<a id="ae9fb7eef54c8ee0a52659dd454a3ef0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fb7eef54c8ee0a52659dd454a3ef0c">&#9670;&nbsp;</a></span>ClampLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> basecross::Vector4EX::ClampLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>LengthMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>LengthMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルの長さを指定した大きさにクランプする </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LengthMin</td><td>長さの最小値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LengthMax</td><td>長さの最大値 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>クランプした結果ベクトル </dd></dl>

</div>
</div>
<a id="a2ab672883516c61d01f97e2581dd726b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab672883516c61d01f97e2581dd726b">&#9670;&nbsp;</a></span>ClampLengthV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> basecross::Vector4EX::ClampLengthV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>LengthMinV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>LengthMaxV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルの長さを指定した大きさにクランプする </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LengthMinV</td><td>長さの最小値(ベクトル) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LengthMaxV</td><td>長さの最大値(ベクトル) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>クランプした結果ベクトル </dd></dl>

</div>
</div>
<a id="a3ef1ab73c59312ab38800abcb6f61bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef1ab73c59312ab38800abcb6f61bfd">&#9670;&nbsp;</a></span>Cross()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> basecross::Vector4EX::Cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>外積を計算して返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec1</td><td>ベクトル1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec2</td><td>ベクトル2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec3</td><td>ベクトル3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>外積 </dd></dl>

</div>
</div>
<a id="af971831697890648e35362b42b1b86fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af971831697890648e35362b42b1b86fc">&#9670;&nbsp;</a></span>Dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float basecross::Vector4EX::Dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>内積を計算して返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec1</td><td>ベクトル1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec2</td><td>ベクトル2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>内積 </dd></dl>

</div>
</div>
<a id="a6b0faec4620e747c1a6a4356fc4e7255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0faec4620e747c1a6a4356fc4e7255">&#9670;&nbsp;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Vector4EX::Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルがもう一つのベクトルと等しいかどうかを検証する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>比較するベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>等しければtrue </dd></dl>

</div>
</div>
<a id="a757ca7049c97e2d47ade7c48fcd94dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757ca7049c97e2d47ade7c48fcd94dfe">&#9670;&nbsp;</a></span>EqualInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Vector4EX::EqualInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルがもう一つのベクトルと等しいかどうかを検証する。<br />
 それぞれの要素は符号なし整数として扱う </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>比較するベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>等しければtrue </dd></dl>

</div>
</div>
<a id="ae10ccda90bd0c54237cdae1c1b92e7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10ccda90bd0c54237cdae1c1b92e7c1">&#9670;&nbsp;</a></span>Greater()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Vector4EX::Greater </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルがもう一つのベクトルより大きいかどうかを検証する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>比較するベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>大きければtrue </dd></dl>

</div>
</div>
<a id="ad16113c4aa25e0543c3aa2270f3f3539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16113c4aa25e0543c3aa2270f3f3539">&#9670;&nbsp;</a></span>GreaterOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Vector4EX::GreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルがもう一つのベクトル以上の大きさかどうかを検証する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>比較するベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>以上の大きさならばtrue </dd></dl>

</div>
</div>
<a id="a12259ca92c539a118b99d86b7d092c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12259ca92c539a118b99d86b7d092c9d">&#9670;&nbsp;</a></span>InBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Vector4EX::InBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>すべての要素が、設定された境界ベクトル内にある場合はtrueを返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec1</td><td>比較元ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec2</td><td>比較するベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>境界内にある場合はtrue </dd></dl>

</div>
</div>
<a id="ab904266a8978c0d23398268dee66b807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab904266a8978c0d23398268dee66b807">&#9670;&nbsp;</a></span>IsInfinite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Vector4EX::IsInfinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルが値のいずれかが正か負の無限大かどうかを検証する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>値のいずれかが正か負の無限大ならばtrue </dd></dl>

</div>
</div>
<a id="ae642ddf936f45812f8ac36093141c1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae642ddf936f45812f8ac36093141c1e6">&#9670;&nbsp;</a></span>IsNaN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Vector4EX::IsNaN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルの値のいずれかが非数（無効値）かどうかを検証する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>値のいずれかが非数（無効値）ならばtrue </dd></dl>

</div>
</div>
<a id="acb89c3ca92fe53a375eb39d581e43a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb89c3ca92fe53a375eb39d581e43a85">&#9670;&nbsp;</a></span>Length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float basecross::Vector4EX::Length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルの長さを返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ベクトルの長さ </dd></dl>

</div>
</div>
<a id="af9ea289b234a23b72eacee963246ac17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ea289b234a23b72eacee963246ac17">&#9670;&nbsp;</a></span>LengthEst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float basecross::Vector4EX::LengthEst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルの長さを予想して返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ベクトルの長さの予想 </dd></dl>

</div>
</div>
<a id="a20acf896961b8c800a03c1e75987cacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20acf896961b8c800a03c1e75987cacc">&#9670;&nbsp;</a></span>LengthSq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float basecross::Vector4EX::LengthSq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルの長さの2乗を返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ベクトルの長さの2乗 </dd></dl>

</div>
</div>
<a id="afbffd9a152c1caafca78670f08c8ab7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbffd9a152c1caafca78670f08c8ab7e">&#9670;&nbsp;</a></span>Less()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Vector4EX::Less </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルがもう一つのベクトルより小さいかどうかを検証する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>比較するベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>小さければtrue </dd></dl>

</div>
</div>
<a id="a6aa1e4298f1175b9bb169167bd16e2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa1e4298f1175b9bb169167bd16e2db">&#9670;&nbsp;</a></span>LessOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Vector4EX::LessOrEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルがもう一つのベクトル以下の大きさかどうかを検証する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>比較するベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>以下の大きさならばtrue </dd></dl>

</div>
</div>
<a id="a72959a69e80b1bbcd3311ba43e79c78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72959a69e80b1bbcd3311ba43e79c78c">&#9670;&nbsp;</a></span>NearEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Vector4EX::NearEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルがもう一つのベクトルが近い大きさかどうかを検証する。 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>比較するベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Epsilon</td><td>比較する最大許容差 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>近い大きさならばtrue </dd></dl>

</div>
</div>
<a id="a4053e6d675ae1335589c615a948d17d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4053e6d675ae1335589c615a948d17d3">&#9670;&nbsp;</a></span>Normalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> basecross::Vector4EX::Normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルを正規化する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>正規化したベクトル </dd></dl>

</div>
</div>
<a id="af8da7c365f396c4ad9d91b3050c47626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8da7c365f396c4ad9d91b3050c47626">&#9670;&nbsp;</a></span>NormalizeEst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> basecross::Vector4EX::NormalizeEst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>正規化の予想ベクトルを返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>正規化の予想ベクトル </dd></dl>

</div>
</div>
<a id="a4a2c4eae4461e9a4e761b111294de417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2c4eae4461e9a4e761b111294de417">&#9670;&nbsp;</a></span>NotEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Vector4EX::NotEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルがもう一つのベクトルと等しくないかどうかを検証する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>比較するベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>等しくなければtrue </dd></dl>

</div>
</div>
<a id="aa91057de115e41b355fde87570cf5f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91057de115e41b355fde87570cf5f2c">&#9670;&nbsp;</a></span>NotEqualInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Vector4EX::NotEqualInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルがもう一つのベクトルと等しくないかどうかを検証する<br />
 それぞれの要素は符号なし整数として扱う </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>比較するベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>等しくなければtrue </dd></dl>

</div>
</div>
<a id="ad232f0c462f525a39c36fe29b0b13f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad232f0c462f525a39c36fe29b0b13f58">&#9670;&nbsp;</a></span>Orthogonal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> basecross::Vector4EX::Orthogonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>垂直なベクトルを返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>垂直なベクトル </dd></dl>

</div>
</div>
<a id="aefe9c2c782ce652d9f121f4c84b3a281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe9c2c782ce652d9f121f4c84b3a281">&#9670;&nbsp;</a></span>ReciprocalLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float basecross::Vector4EX::ReciprocalLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルの長さの逆数を返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ベクトルの長さの逆数 </dd></dl>

</div>
</div>
<a id="aab4f0def784a2561185ec00cb3dc375e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4f0def784a2561185ec00cb3dc375e">&#9670;&nbsp;</a></span>ReciprocalLengthEst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float basecross::Vector4EX::ReciprocalLengthEst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルの長さの逆数の予測値を返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ベクトルの長さの逆数の予測値 </dd></dl>

</div>
</div>
<a id="aad746317e16d70554496f2e0e7e27244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad746317e16d70554496f2e0e7e27244">&#9670;&nbsp;</a></span>Reflect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> basecross::Vector4EX::Reflect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルを法線ベクトルによって反射させたベクトル(入射ベクトル)を返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Normal</td><td>法線ベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>反射させたベクトル </dd></dl>

</div>
</div>
<a id="ad29bbccba62830f569f54b9476c5c4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29bbccba62830f569f54b9476c5c4d7">&#9670;&nbsp;</a></span>Refract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> basecross::Vector4EX::Refract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>RefractionIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルを法線ベクトルによって屈折率で反射させたベクトル(入射ベクトル)を返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Normal</td><td>屈折させる法線ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RefractionIndex</td><td>屈折率 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>反射させたベクトル </dd></dl>

</div>
</div>
<a id="a669b849a4b9e51f47aa544ab011edc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669b849a4b9e51f47aa544ab011edc74">&#9670;&nbsp;</a></span>RefractV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> basecross::Vector4EX::RefractV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>RefractionIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルを法線ベクトルによって屈折率ベクトル（すべての要素が同じ値）で反射させたベクトル(入射ベクトル)を返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Normal</td><td>屈折させる法線ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RefractionIndex</td><td>屈折率ベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>反射させたベクトル </dd></dl>

</div>
</div>
<a id="af8c818b95198662687b233fe82194933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c818b95198662687b233fe82194933">&#9670;&nbsp;</a></span>Transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> basecross::Vector4EX::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XMMATRIX &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルをmによってトランスフォームさせたベクトルを返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>トランスフォームする行列 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>トランスフォームさせたベクトル </dd></dl>

</div>
</div>
<a id="af7216ec7f137e6f17fcaf2521d9fe97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7216ec7f137e6f17fcaf2521d9fe97b">&#9670;&nbsp;</a></span>Transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> basecross::Vector4EX::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_matrix4_x4.html">Matrix4X4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ベクトルをmによってトランスフォームさせたベクトルを返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td>ベクトル </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>トランスフォームする行列 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>トランスフォームさせたベクトル </dd></dl>

</div>
</div>
<a id="a0a66d829f89eaf01f07e20eb516363d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a66d829f89eaf01f07e20eb516363d4">&#9670;&nbsp;</a></span>WStr4ToVec4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> basecross::Vector4EX::WStr4ToVec4 </td>
          <td>(</td>
          <td class="paramtype">wstring &amp;&#160;</td>
          <td class="paramname"><em>x_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wstring &amp;&#160;</td>
          <td class="paramname"><em>y_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wstring &amp;&#160;</td>
          <td class="paramname"><em>z_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wstring &amp;&#160;</td>
          <td class="paramname"><em>w_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>文字列から作成する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x_str</td><td>X数値に変換できる文字列 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_str</td><td>Y数値に変換できる文字列 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z_str</td><td>Z数値に変換できる文字列 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w_str</td><td>W数値に変換できる文字列 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>作成したベクトル </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
構築: &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

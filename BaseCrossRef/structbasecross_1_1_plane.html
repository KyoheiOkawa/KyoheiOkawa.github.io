<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BaseCrossRef: basecross::Plane 構造体</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BaseCrossRef
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebasecross.html">basecross</a></li><li class="navelem"><a class="el" href="structbasecross_1_1_plane.html">Plane</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="structbasecross_1_1_plane-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">basecross::Plane 構造体</div>  </div>
</div><!--header-->
<div class="contents">

<p>Plane（平面）構造体  
 <a href="structbasecross_1_1_plane.html#details">[詳解]</a></p>

<p><code>#include &lt;<a class="el" href="_math_ext_8h_source.html">MathExt.h</a>&gt;</code></p>
<div class="dynheader">
basecross::Plane の継承関係図</div>
<div class="dyncontent">
 <div class="center">
  <img src="structbasecross_1_1_plane.png" usemap="#basecross::Plane_map" alt=""/>
  <map id="basecross::Plane_map" name="basecross::Plane_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a758d382ae061fa4771b3a7c149fb7c03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a758d382ae061fa4771b3a7c149fb7c03">Plane</a> ()</td></tr>
<tr class="memdesc:a758d382ae061fa4771b3a7c149fb7c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンストラクタ  <a href="#a758d382ae061fa4771b3a7c149fb7c03">[詳解]</a><br /></td></tr>
<tr class="separator:a758d382ae061fa4771b3a7c149fb7c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d2c54d200aeec908a1e20e65523d11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a18d2c54d200aeec908a1e20e65523d11">Plane</a> (const XMFLOAT4 &amp;v4)</td></tr>
<tr class="memdesc:a18d2c54d200aeec908a1e20e65523d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンストラクタ  <a href="#a18d2c54d200aeec908a1e20e65523d11">[詳解]</a><br /></td></tr>
<tr class="separator:a18d2c54d200aeec908a1e20e65523d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4beca497181bfa173e0cfd8ac3c2b95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#ab4beca497181bfa173e0cfd8ac3c2b95">Plane</a> (const <a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;other)</td></tr>
<tr class="memdesc:ab4beca497181bfa173e0cfd8ac3c2b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">コピーコンストラクタ  <a href="#ab4beca497181bfa173e0cfd8ac3c2b95">[詳解]</a><br /></td></tr>
<tr class="separator:ab4beca497181bfa173e0cfd8ac3c2b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553ebecf384f53b4d3d17cc2427068fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a553ebecf384f53b4d3d17cc2427068fc">Plane</a> (const XMVECTOR &amp;other)</td></tr>
<tr class="memdesc:a553ebecf384f53b4d3d17cc2427068fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンストラクタ  <a href="#a553ebecf384f53b4d3d17cc2427068fc">[詳解]</a><br /></td></tr>
<tr class="separator:a553ebecf384f53b4d3d17cc2427068fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fec1a09de799a1ed20db4c12b248b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a99fec1a09de799a1ed20db4c12b248b8">Plane</a> (const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;Point, const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;Normal)</td></tr>
<tr class="memdesc:a99fec1a09de799a1ed20db4c12b248b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンストラクタ  <a href="#a99fec1a09de799a1ed20db4c12b248b8">[詳解]</a><br /></td></tr>
<tr class="separator:a99fec1a09de799a1ed20db4c12b248b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d760da99e51dff1eafb8e902681296b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a3d760da99e51dff1eafb8e902681296b">Plane</a> (const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;Point1, const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;Point2, const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;Point3)</td></tr>
<tr class="memdesc:a3d760da99e51dff1eafb8e902681296b"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンストラクタ  <a href="#a3d760da99e51dff1eafb8e902681296b">[詳解]</a><br /></td></tr>
<tr class="separator:a3d760da99e51dff1eafb8e902681296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c76e232e704552161f904155cd86951"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a2c76e232e704552161f904155cd86951">operator XMVECTOR</a> () const</td></tr>
<tr class="memdesc:a2c76e232e704552161f904155cd86951"><td class="mdescLeft">&#160;</td><td class="mdescRight">XMVECTORへのキャスト（thisをキャストして返す）  <a href="#a2c76e232e704552161f904155cd86951">[詳解]</a><br /></td></tr>
<tr class="separator:a2c76e232e704552161f904155cd86951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46474839693afb8499ffb55cb795cf5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a46474839693afb8499ffb55cb795cf5f">Set</a> (float xx, float yy, float zz, float ww)</td></tr>
<tr class="memdesc:a46474839693afb8499ffb55cb795cf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">メンバ変数への直接代入  <a href="#a46474839693afb8499ffb55cb795cf5f">[詳解]</a><br /></td></tr>
<tr class="separator:a46474839693afb8499ffb55cb795cf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb421c2dffced527e768660984582a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#affb421c2dffced527e768660984582a9">Zero</a> ()</td></tr>
<tr class="memdesc:affb421c2dffced527e768660984582a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">0初期化（すべてを0にする）  <a href="#affb421c2dffced527e768660984582a9">[詳解]</a><br /></td></tr>
<tr class="separator:affb421c2dffced527e768660984582a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca66f4af76ad841e1401ba2bcb6d92d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#aaca66f4af76ad841e1401ba2bcb6d92d">operator=</a> (const <a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;other)</td></tr>
<tr class="memdesc:aaca66f4af76ad841e1401ba2bcb6d92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">代入  <a href="#aaca66f4af76ad841e1401ba2bcb6d92d">[詳解]</a><br /></td></tr>
<tr class="separator:aaca66f4af76ad841e1401ba2bcb6d92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189b724aad95aee66ee6b80fb24058fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a189b724aad95aee66ee6b80fb24058fc">operator=</a> (const XMVECTOR &amp;other)</td></tr>
<tr class="memdesc:a189b724aad95aee66ee6b80fb24058fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">代入  <a href="#a189b724aad95aee66ee6b80fb24058fc">[詳解]</a><br /></td></tr>
<tr class="separator:a189b724aad95aee66ee6b80fb24058fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a67357e0ae8f2fa72aed4bc41cf28e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#ad4a67357e0ae8f2fa72aed4bc41cf28e">Dot</a> (const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;other) const</td></tr>
<tr class="memdesc:ad4a67357e0ae8f2fa72aed4bc41cf28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">thisとother（Vector4）の内積を返す  <a href="#ad4a67357e0ae8f2fa72aed4bc41cf28e">[詳解]</a><br /></td></tr>
<tr class="separator:ad4a67357e0ae8f2fa72aed4bc41cf28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4445bc6e78015456cfb0b7ceec9aff2b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a4445bc6e78015456cfb0b7ceec9aff2b">DotCoord</a> (const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;other) const</td></tr>
<tr class="memdesc:a4445bc6e78015456cfb0b7ceec9aff2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">thisとother（Vector3）の内積を返す  <a href="#a4445bc6e78015456cfb0b7ceec9aff2b">[詳解]</a><br /></td></tr>
<tr class="separator:a4445bc6e78015456cfb0b7ceec9aff2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac729dbe205d077f7e63ab14c202ec83b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#ac729dbe205d077f7e63ab14c202ec83b">DotNormal</a> (const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;other) const</td></tr>
<tr class="memdesc:ac729dbe205d077f7e63ab14c202ec83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">平面の法線ベクトルととother（Vector3）の内積を返す  <a href="#ac729dbe205d077f7e63ab14c202ec83b">[詳解]</a><br /></td></tr>
<tr class="separator:ac729dbe205d077f7e63ab14c202ec83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8de09c07fa13ce501f9cf91691a4bb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#ad8de09c07fa13ce501f9cf91691a4bb9">Equal</a> (const <a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;other) const</td></tr>
<tr class="memdesc:ad8de09c07fa13ce501f9cf91691a4bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">thisと相手の平面が同じかどうかを調べる  <a href="#ad8de09c07fa13ce501f9cf91691a4bb9">[詳解]</a><br /></td></tr>
<tr class="separator:ad8de09c07fa13ce501f9cf91691a4bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9afb63e7c93356260ea88f9077c964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a6b9afb63e7c93356260ea88f9077c964">FromPointNormal</a> (const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;Point, const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;Normal)</td></tr>
<tr class="memdesc:a6b9afb63e7c93356260ea88f9077c964"><td class="mdescLeft">&#160;</td><td class="mdescRight">点と法線から平面を作成して、thisに設定する  <a href="#a6b9afb63e7c93356260ea88f9077c964">[詳解]</a><br /></td></tr>
<tr class="separator:a6b9afb63e7c93356260ea88f9077c964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e85c655b17a5103eac39ae7b749f097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a2e85c655b17a5103eac39ae7b749f097">FromPoints</a> (const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;Point1, const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;Point2, const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;Point3)</td></tr>
<tr class="memdesc:a2e85c655b17a5103eac39ae7b749f097"><td class="mdescLeft">&#160;</td><td class="mdescRight">３点から平面を作成して、thisに設定する  <a href="#a2e85c655b17a5103eac39ae7b749f097">[詳解]</a><br /></td></tr>
<tr class="separator:a2e85c655b17a5103eac39ae7b749f097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e43bd4d3d1c30cc97464eb4c2c94b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbasecross_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a00e43bd4d3d1c30cc97464eb4c2c94b7">IntersectLine</a> (const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;LinePoint1, const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;LinePoint2) const</td></tr>
<tr class="memdesc:a00e43bd4d3d1c30cc97464eb4c2c94b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">thisと２つの頂点が作成する直線の交差する頂点を返す<br />
 平面と直線が平行の場合は、戻る各値はQNaN（非数） になるので、<br />
 <a class="el" href="structbasecross_1_1_vector3.html#a2432af0a43bd3b7a46a18bdb56fab7b1" title="thisの値のいずれかが非数（無効値）かどうかを検証する。 ">Vector3::IsNaN()</a>などでチェックする  <a href="#a00e43bd4d3d1c30cc97464eb4c2c94b7">[詳解]</a><br /></td></tr>
<tr class="separator:a00e43bd4d3d1c30cc97464eb4c2c94b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60b10443c415b8b5dca044933f6b762"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#ad60b10443c415b8b5dca044933f6b762">IntersectPlane</a> (<a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;RetLinePoint1, <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;RetLinePoint2, const <a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;other) const</td></tr>
<tr class="memdesc:ad60b10443c415b8b5dca044933f6b762"><td class="mdescLeft">&#160;</td><td class="mdescRight">thisともう一つの面が交差する2つの頂点を計算する<br />
 2つの平面が平行の場合は、戻る各値はQNaN（非数） になるので、<br />
 <a class="el" href="structbasecross_1_1_vector3.html#a2432af0a43bd3b7a46a18bdb56fab7b1" title="thisの値のいずれかが非数（無効値）かどうかを検証する。 ">Vector3::IsNaN()</a>などでチェックする  <a href="#ad60b10443c415b8b5dca044933f6b762">[詳解]</a><br /></td></tr>
<tr class="separator:ad60b10443c415b8b5dca044933f6b762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d099a312ec4f1c4272391c90614a3a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a3d099a312ec4f1c4272391c90614a3a9">IsInfinite</a> () const</td></tr>
<tr class="memdesc:a3d099a312ec4f1c4272391c90614a3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">thisの要素のいずれかが正または負の無限大かどうかを調べる  <a href="#a3d099a312ec4f1c4272391c90614a3a9">[詳解]</a><br /></td></tr>
<tr class="separator:a3d099a312ec4f1c4272391c90614a3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8922dd639825207a325555abb934833"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#ac8922dd639825207a325555abb934833">IsNaN</a> () const</td></tr>
<tr class="memdesc:ac8922dd639825207a325555abb934833"><td class="mdescLeft">&#160;</td><td class="mdescRight">thisの要素のいずれかが NaNかどうかを調べる  <a href="#ac8922dd639825207a325555abb934833">[詳解]</a><br /></td></tr>
<tr class="separator:ac8922dd639825207a325555abb934833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcc23caecdba79cf9ccc61dfb1d5ed4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#a6fcc23caecdba79cf9ccc61dfb1d5ed4">NearEqual</a> (const <a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;other, const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;Epsilon) const</td></tr>
<tr class="memdesc:a6fcc23caecdba79cf9ccc61dfb1d5ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">thisともう一つの平面がほぼ等しいかどうか調べる  <a href="#a6fcc23caecdba79cf9ccc61dfb1d5ed4">[詳解]</a><br /></td></tr>
<tr class="separator:a6fcc23caecdba79cf9ccc61dfb1d5ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27354f968c68c1a923d55b902b1e692"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#af27354f968c68c1a923d55b902b1e692">Normalize</a> ()</td></tr>
<tr class="memdesc:af27354f968c68c1a923d55b902b1e692"><td class="mdescLeft">&#160;</td><td class="mdescRight">thisを正規化する(＊thisに結果を設定する)  <a href="#af27354f968c68c1a923d55b902b1e692">[詳解]</a><br /></td></tr>
<tr class="separator:af27354f968c68c1a923d55b902b1e692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bf314d001b4e62fafa1a51e70cde13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#ad7bf314d001b4e62fafa1a51e70cde13">NormalizeEst</a> ()</td></tr>
<tr class="memdesc:ad7bf314d001b4e62fafa1a51e70cde13"><td class="mdescLeft">&#160;</td><td class="mdescRight">thisをx,y,zの係数が単位の法線ベクトルを形成するように<br />
 平面の係数を予測(＊thisに結果を設定する)  <a href="#ad7bf314d001b4e62fafa1a51e70cde13">[詳解]</a><br /></td></tr>
<tr class="separator:ad7bf314d001b4e62fafa1a51e70cde13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25bf4bfd1b263d640f945266aed3faf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#ae25bf4bfd1b263d640f945266aed3faf">NotEqual</a> (const <a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;other) const</td></tr>
<tr class="memdesc:ae25bf4bfd1b263d640f945266aed3faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">thisと相手の平面が等しくないかどうかを調べる  <a href="#ae25bf4bfd1b263d640f945266aed3faf">[詳解]</a><br /></td></tr>
<tr class="separator:ae25bf4bfd1b263d640f945266aed3faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71835a01096842373d716e97f32c12e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbasecross_1_1_plane.html#ab71835a01096842373d716e97f32c12e">Transform</a> (const XMMATRIX &amp;m)</td></tr>
<tr class="memdesc:ab71835a01096842373d716e97f32c12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">thisをmでトランスフォームする(＊thisに結果を設定する)  <a href="#ab71835a01096842373d716e97f32c12e">[詳解]</a><br /></td></tr>
<tr class="separator:ab71835a01096842373d716e97f32c12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>Plane（平面）構造体 </p>
</div><h2 class="groupheader">構築子と解体子</h2>
<a id="a758d382ae061fa4771b3a7c149fb7c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758d382ae061fa4771b3a7c149fb7c03">&#9670;&nbsp;</a></span>Plane() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basecross::Plane::Plane </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>コンストラクタ </p>

</div>
</div>
<a id="a18d2c54d200aeec908a1e20e65523d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d2c54d200aeec908a1e20e65523d11">&#9670;&nbsp;</a></span>Plane() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basecross::Plane::Plane </td>
          <td>(</td>
          <td class="paramtype">const XMFLOAT4 &amp;&#160;</td>
          <td class="paramname"><em>v4</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>コンストラクタ </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v4</td><td>XMFLOAT4構造体 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4beca497181bfa173e0cfd8ac3c2b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4beca497181bfa173e0cfd8ac3c2b95">&#9670;&nbsp;</a></span>Plane() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basecross::Plane::Plane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>コピーコンストラクタ </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>コピー元Plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a553ebecf384f53b4d3d17cc2427068fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553ebecf384f53b4d3d17cc2427068fc">&#9670;&nbsp;</a></span>Plane() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basecross::Plane::Plane </td>
          <td>(</td>
          <td class="paramtype">const XMVECTOR &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>コンストラクタ </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>コピー元XMVECTOR </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99fec1a09de799a1ed20db4c12b248b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fec1a09de799a1ed20db4c12b248b8">&#9670;&nbsp;</a></span>Plane() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basecross::Plane::Plane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>Point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>Normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>コンストラクタ </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Point</td><td>面上に存在する点 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Normal</td><td>法線 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d760da99e51dff1eafb8e902681296b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d760da99e51dff1eafb8e902681296b">&#9670;&nbsp;</a></span>Plane() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basecross::Plane::Plane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>Point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>Point2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>Point3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>コンストラクタ </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Point1</td><td>面上に存在する点1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Point2</td><td>面上に存在する点2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Point3</td><td>面上に存在する点3 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="ad4a67357e0ae8f2fa72aed4bc41cf28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a67357e0ae8f2fa72aed4bc41cf28e">&#9670;&nbsp;</a></span>Dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float basecross::Plane::Dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>thisとother（Vector4）の内積を返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>相手のベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>内積。平面と同次座標の関係を判定するときに役立つ。<br />
 たとえば、この関数を使用してある座標が特定の平面上に存在するか、<br />
 または座標が平面のどちら側に存在するかなどを判定できる。 </dd></dl>

</div>
</div>
<a id="a4445bc6e78015456cfb0b7ceec9aff2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4445bc6e78015456cfb0b7ceec9aff2b">&#9670;&nbsp;</a></span>DotCoord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float basecross::Plane::DotCoord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>thisとother（Vector3）の内積を返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>相手のベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>内積。あるポイントから平面までの符号付き距離を求めるのに便利である </dd></dl>

</div>
</div>
<a id="ac729dbe205d077f7e63ab14c202ec83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac729dbe205d077f7e63ab14c202ec83b">&#9670;&nbsp;</a></span>DotNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float basecross::Plane::DotNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>平面の法線ベクトルととother（Vector3）の内積を返す </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>比べるベクトル </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>内積。平面の法線ベクトルと別の法線ベクトルとの角度を算出するときに役立つ。 </dd></dl>

</div>
</div>
<a id="ad8de09c07fa13ce501f9cf91691a4bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8de09c07fa13ce501f9cf91691a4bb9">&#9670;&nbsp;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Plane::Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>thisと相手の平面が同じかどうかを調べる </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>相手のPlane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>同じならtrue </dd></dl>

</div>
</div>
<a id="a6b9afb63e7c93356260ea88f9077c964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9afb63e7c93356260ea88f9077c964">&#9670;&nbsp;</a></span>FromPointNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void basecross::Plane::FromPointNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>Point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>Normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>点と法線から平面を作成して、thisに設定する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Point</td><td>平面上の点 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Normal</td><td>法線 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>なし </dd></dl>

</div>
</div>
<a id="a2e85c655b17a5103eac39ae7b749f097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e85c655b17a5103eac39ae7b749f097">&#9670;&nbsp;</a></span>FromPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void basecross::Plane::FromPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>Point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>Point2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>Point3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>３点から平面を作成して、thisに設定する </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Point1</td><td>頂点1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Point2</td><td>頂点2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Point3</td><td>頂点3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>なし </dd></dl>

</div>
</div>
<a id="a00e43bd4d3d1c30cc97464eb4c2c94b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e43bd4d3d1c30cc97464eb4c2c94b7">&#9670;&nbsp;</a></span>IntersectLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> basecross::Plane::IntersectLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>LinePoint1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>LinePoint2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>thisと２つの頂点が作成する直線の交差する頂点を返す<br />
 平面と直線が平行の場合は、戻る各値はQNaN（非数） になるので、<br />
 <a class="el" href="structbasecross_1_1_vector3.html#a2432af0a43bd3b7a46a18bdb56fab7b1" title="thisの値のいずれかが非数（無効値）かどうかを検証する。 ">Vector3::IsNaN()</a>などでチェックする </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">LinePoint1</td><td>頂点1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LinePoint2</td><td>頂点2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>thisと交差する３Ｄベクトル </dd></dl>

</div>
</div>
<a id="ad60b10443c415b8b5dca044933f6b762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60b10443c415b8b5dca044933f6b762">&#9670;&nbsp;</a></span>IntersectPlane()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void basecross::Plane::IntersectPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>RetLinePoint1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbasecross_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>RetLinePoint2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>thisともう一つの面が交差する2つの頂点を計算する<br />
 2つの平面が平行の場合は、戻る各値はQNaN（非数） になるので、<br />
 <a class="el" href="structbasecross_1_1_vector3.html#a2432af0a43bd3b7a46a18bdb56fab7b1" title="thisの値のいずれかが非数（無効値）かどうかを検証する。 ">Vector3::IsNaN()</a>などでチェックする </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">RetLinePoint1</td><td>返される頂点1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RetLinePoint2</td><td>返される頂点2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>thisと比べられるもう一つの面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>なし </dd></dl>

</div>
</div>
<a id="a3d099a312ec4f1c4272391c90614a3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d099a312ec4f1c4272391c90614a3a9">&#9670;&nbsp;</a></span>IsInfinite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Plane::IsInfinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>thisの要素のいずれかが正または負の無限大かどうかを調べる </p>
<dl class="section return"><dt>戻り値</dt><dd>正または負の無限大ならtrue </dd></dl>

</div>
</div>
<a id="ac8922dd639825207a325555abb934833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8922dd639825207a325555abb934833">&#9670;&nbsp;</a></span>IsNaN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Plane::IsNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>thisの要素のいずれかが NaNかどうかを調べる </p>
<dl class="section return"><dt>戻り値</dt><dd>NaNならtrue </dd></dl>

</div>
</div>
<a id="a6fcc23caecdba79cf9ccc61dfb1d5ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fcc23caecdba79cf9ccc61dfb1d5ed4">&#9670;&nbsp;</a></span>NearEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Plane::NearEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>Epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>thisともう一つの平面がほぼ等しいかどうか調べる </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>thisと比べられるもう一つの面 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Epsilon</td><td>各要素の許容範囲 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>ほぼ等しければtrue </dd></dl>

</div>
</div>
<a id="af27354f968c68c1a923d55b902b1e692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27354f968c68c1a923d55b902b1e692">&#9670;&nbsp;</a></span>Normalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void basecross::Plane::Normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>thisを正規化する(＊thisに結果を設定する) </p>
<dl class="section return"><dt>戻り値</dt><dd>なし </dd></dl>

</div>
</div>
<a id="ad7bf314d001b4e62fafa1a51e70cde13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bf314d001b4e62fafa1a51e70cde13">&#9670;&nbsp;</a></span>NormalizeEst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void basecross::Plane::NormalizeEst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>thisをx,y,zの係数が単位の法線ベクトルを形成するように<br />
 平面の係数を予測(＊thisに結果を設定する) </p>
<dl class="section return"><dt>戻り値</dt><dd>なし </dd></dl>

</div>
</div>
<a id="ae25bf4bfd1b263d640f945266aed3faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25bf4bfd1b263d640f945266aed3faf">&#9670;&nbsp;</a></span>NotEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool basecross::Plane::NotEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>thisと相手の平面が等しくないかどうかを調べる </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>相手のPlane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>等しくないならtrue </dd></dl>

</div>
</div>
<a id="a2c76e232e704552161f904155cd86951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c76e232e704552161f904155cd86951">&#9670;&nbsp;</a></span>operator XMVECTOR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">basecross::Plane::operator XMVECTOR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>XMVECTORへのキャスト（thisをキャストして返す） </p>
<dl class="section return"><dt>戻り値</dt><dd>XMVECTOR型の値 </dd></dl>

</div>
</div>
<a id="aaca66f4af76ad841e1401ba2bcb6d92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca66f4af76ad841e1401ba2bcb6d92d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_plane.html">Plane</a>&amp; basecross::Plane::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbasecross_1_1_plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>代入 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>コピー元 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>*thisの参照 </dd></dl>

</div>
</div>
<a id="a189b724aad95aee66ee6b80fb24058fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189b724aad95aee66ee6b80fb24058fc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbasecross_1_1_plane.html">Plane</a>&amp; basecross::Plane::operator= </td>
          <td>(</td>
          <td class="paramtype">const XMVECTOR &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>代入 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>コピー元(XMVECTOR型) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>*thisの参照 </dd></dl>

</div>
</div>
<a id="a46474839693afb8499ffb55cb795cf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46474839693afb8499ffb55cb795cf5f">&#9670;&nbsp;</a></span>Set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void basecross::Plane::Set </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ww</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>メンバ変数への直接代入 </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xx</td><td>x値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yy</td><td>y値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zz</td><td>z値 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ww</td><td>w値 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>なし </dd></dl>

</div>
</div>
<a id="ab71835a01096842373d716e97f32c12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71835a01096842373d716e97f32c12e">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void basecross::Plane::Transform </td>
          <td>(</td>
          <td class="paramtype">const XMMATRIX &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>thisをmでトランスフォームする(＊thisに結果を設定する) </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>トランスフォームする行列 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>なし </dd></dl>

</div>
</div>
<a id="affb421c2dffced527e768660984582a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb421c2dffced527e768660984582a9">&#9670;&nbsp;</a></span>Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void basecross::Plane::Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>0初期化（すべてを0にする） </p>
<dl class="section return"><dt>戻り値</dt><dd>なし </dd></dl>

</div>
</div>
<hr/>この構造体詳解は次のファイルから抽出されました:<ul>
<li>D:/GitRepository/GitHub/BaseCross/Libs/BaseLib/DxLib/<a class="el" href="_math_ext_8h_source.html">MathExt.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
構築: &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
